##Arranjos e Matrizes

#Definição matemática

São variáveis continua acessadas por um número de índice. Vetores contém apenas uma dimensão e Matrizes pode conter várias.

#Declaração de arranjos

int vetor[]; = declaração do vetor

vetor = new int[8]; = definição de espação para o vetor

#Declaração de matrizes

int m[][] = new int[3][3]; // matriz quadrada: 3 linhas X 3 colunas

int m[][] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };

// 1ª linha:
 m[0][0] = 1;
 m[0][1] = 2;
 m[0][2] = 3;

 // 2ª linha:
 m[1][0] = 4;
 m[1][1] = 5;
 m[1][2] = 6;

 // 3ª linha:
 m[2][0] = 7;
 m[2][1] = 8;
 m[2][2] = 9;
 
 #Percorrer arranjos
 
 public static void main(String[] args) {
    int[] numeros = new int[10];
    for (int i = 0; i < 20; i++) {
        numeros[i] = i * 20;}
    for (int i = 0; i < 20; i++) {
        System.out.println(numeros[i]);
    }
}

#Percorrer matrizes

Exemplos de como percorrer por linha e coluna:

Linha

public static char[][] bidArray = new char[]{{'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'}};
  public static void main(String[] args) {
  System.out.println("Percorrendo linhas:");
    for(char[] linha: bidArray){            
       System.out.println(Arrays.toString(linha));


Coluna

private void intervaloColuna(int inicio, int fim) {
        for (int linha = 0; linha < suatabela.getRowCount(); linha++) {
            for (int coluna = inicio; coluna <= fim; coluna++) {
                System.out.print(suatabela.getValueAt(linha, coluna) + " ");
            }
            System.out.println("");
        }
    }
   
Diagonal

public static void main(String[] args) throws Exception {
String str = "1234";
int size = 3;

int[][] matrix = new int[size][size];
{
    int index = 0;
    for (int diagonal = 0; diagonal < size * 2 - 1; diagonal++) {
        int row = diagonal;
        int column = 0;
        while (row >= 0) {
            if (row < size && column < size) {
                matrix[size - row - 1][column] = Character.getNumericValue(str.charAt(index++));
            }
            row--;
            column++;
        }
    }
  }
}

#Utilizar arranjos e matrizes como parâmetros de métodos

Arranjos = 
public class Main {   
   
public void ordint(int[]vetor) {   
    Arrays.sort(vetor);   
    int vtamanho = vetor.length;  
    for (int i = 0; i < vtamanho; i++) {    
        System.out.println(vetor[i]);   
        }
   }  
Matriz = 
   public void mostra(int matriz[][]){
    for(int i=0;i<lin;i++){
        System.out.println("");
    for(int j=0;j<col;j++){
        System.out.print(mat[i][j]+" ");
        }
       }
       
#Utilizar arranjos e matrizes como retorno de métodos

public class Main{
          public static void main(String[] args){
              int[] arr1 = {1, 2, 3, 4, 5};
              int[] arr2 = {2, 4, 6, 8, 10};
              addArrays(arr1, arr2);
          }
      }
 
 
 ---------------------------------------------------------------------------------------------------------------------
 
 ##Tratamento de exceções
 
 #Definição
 
 Criar tratamento para possíveis erros que podem vir da lógica do código ou ligados ao usuário:
 
 try
{
  //código que será realizado a exceção
}
catch(tipo_exceçao e)
{
  //ação
  
#Exceções comuns

#Divisão por 0

int a = 6;
int b = 0;
System.out.print(a / b);

catch (ArithmeticException e) {
System.out.println
("não é possível dividir por 0");

#Conversão de tipos de dados inválidos

public class Main {
     public static void main(String[] args) {
	try{
		Object o = new Object();
		String s = (String) o;
	} catch (Exception e) {
		System.out.println("Conversão Inválida"); 
	}
	}
  
#Acessar uma posição inválida em um arranjo

public static void main(String[] args) {
            try {
                ArrayList arl = new ArrayList<>();
                  lrl.get(99)
            } catch (IndexOutOfBoundsException  e) {
                System.out.print("Possição não encontrada");
            }
        }
 
#Acessar uma String nula

String s = null
		s.replace ("","")
		System.out.println("String substituida");
	}catch (NullPointerException e){
		System.out.println("String null");
	}catch (Exception e){
           e.printStackTrace();
        }
      }

  #Bloco para capturar uma exceção
  
  catch (NumberException i) { //exceção
  
  #Bloco para capturar diferentes exceções
  
 catch (NumberException i) { //várias exceções
 
 #Bloco finally
 
 finally { //comando para finalizar o bloco de exceção
 
 
#Lançar uma exceção

public class Main {
public static void main(String[] args)
 throws Exception{
  throw new Exception("Exceção");
  }
  
  
  ------------------------------------------------------------------------------------------------------------------------------
 
##Métodos estáticos

#Estrutura de declaração de um método estático

public static void  main (String [] args) {  
  mostrar();  
}  
static void ver() {  
  System.out.println ( "Hello World!" );  
}  

#Nomes válidos e boas práticas

-Padrões de camel case
-Classes gramaticais

#Parâmetros

public static void main(String[] args) {
Scanner leia = new Scanner(System.in);
System.out.println("Informe o número: ");
double n1 = leia.nextDouble(); 
//condições para receber os valores

#Retorno

Utilizado para retornar o valor

##Utilização de métodos estáticos

#Disponíveis na mesma classe

public static void  main (String [] args) {  
  System.out.println("Hello";  
}  

#Disponíveis em outra classe/arquivo

class Loja{
    static String number;

static String getNumber() {
	return number;
}

#Recursão

def carrossum(numCarros):
theSum = 0
for i in numCarros:
theSum = theSum + i
return theSum
print(carrossum([1,3])

----------------------------------------------------------------------------

##Classe

#Definição

É um elemento do java que é usado para representar os objetos.

#Uml =    ![image](https://user-images.githubusercontent.com/106282703/190491905-6debe929-a462-42f2-8866-e016af85722f.png)

#Diferença entre classe e objeto

Classe = Representa um conjunto de objetos 
Objeto = Instancia da classe, elemento da classe

#Atributos

Variárveis que são propriedades de um objeto.

public class celular{
   	public String marca;
    	public int bits;
   	public int polegadas;
    }

#Métodos

Servem para se comunicar entre os objetos

class celular{
    int polegadas;
    String name;
    void tocar(){
	if(tamanho > 0)
	System.out.println("Plim Plim);

#Construtor

Responsáveis por criar o objeto em memória

public class Carro{

private String cor;
private double preco;
private String modelo;

/* CONSTRUTOR PADRÃO */
public Carro(){

#Objeto

Caracteristicas definidas pelas classes.

#Inicialização de um objeto

Os objetos podem ser chamados por métodos e contrutores.

#Utilização de um objeto

A chamada do objeto é utilizada com o seguinte operador: new Classe();

#Comparação de objetos

Método utilizado para comparar objetos: equals();

#Método toString

toString retorna uma representação string de um objeto.

package java.lang;
public class Object {
public String toString() {
return getClass().getName() + “@” + Integer.toHexString(hashCode());
}

##Visibilidade de atributos e métodos

#Público

É a visibilidade da classe dentro do pacote, no caso do public, é a classe que está disponível para todos no mesmo pacote.

#Privado

A única classe que tem acesso ao atributo é a própria classe que o define.

#Sobrecarga de métodos

Consiste na criação de variações de um mesmo método, ou seja, a criação de dois ou mais 
métodos com nomes totalmente iguais em uma classe.

class Carro {}
class Motocicleta {}
class Caminhonete {}
public class Personagem {
    public void acelerarCarro(Carro carro) {}
    public void acelerarMotocicleta(Motocicleta motocicleta) {}
    public void acelerarCaminhonete(Caminhonete caminhonete) {}
    
    
#Sobrecarga de construtores

É criar vários construtores na mesma classe.

-------------------------------------------------------------------------------------------------------------------------------













  
  
 
 
 
 
 
 
 


