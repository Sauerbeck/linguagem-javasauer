##Arranjos e Matrizes

#Definição matemática

São variáveis continua acessadas por um número de índice. Vetores contém apenas uma dimensão e Matrizes pode conter várias.

#Declaração de arranjos

int vetor[]; = declaração do vetor

vetor = new int[8]; = definição de espação para o vetor

#Declaração de matrizes

int m[][] = new int[3][3]; // matriz quadrada: 3 linhas X 3 colunas

int m[][] = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };

// 1ª linha:
 m[0][0] = 1;
 m[0][1] = 2;
 m[0][2] = 3;

 // 2ª linha:
 m[1][0] = 4;
 m[1][1] = 5;
 m[1][2] = 6;

 // 3ª linha:
 m[2][0] = 7;
 m[2][1] = 8;
 m[2][2] = 9;
 
 #Percorrer arranjos
 
 public static void main(String[] args) {
    int[] numeros = new int[10];
    for (int i = 0; i < 20; i++) {
        numeros[i] = i * 20;}
    for (int i = 0; i < 20; i++) {
        System.out.println(numeros[i]);
    }
}

#Percorrer matrizes

Exemplos de como percorrer por linha e coluna:

Linha

public static char[][] bidArray = new char[]{{'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'}};
  public static void main(String[] args) {
  System.out.println("Percorrendo linhas:");
    for(char[] linha: bidArray){            
       System.out.println(Arrays.toString(linha));


Coluna

private void intervaloColuna(int inicio, int fim) {
        for (int linha = 0; linha < suatabela.getRowCount(); linha++) {
            for (int coluna = inicio; coluna <= fim; coluna++) {
                System.out.print(suatabela.getValueAt(linha, coluna) + " ");
            }
            System.out.println("");
        }
    }
   
Diagonal

public static void main(String[] args) throws Exception {
String str = "1234";
int size = 3;

int[][] matrix = new int[size][size];
{
    int index = 0;
    for (int diagonal = 0; diagonal < size * 2 - 1; diagonal++) {
        int row = diagonal;
        int column = 0;
        while (row >= 0) {
            if (row < size && column < size) {
                matrix[size - row - 1][column] = Character.getNumericValue(str.charAt(index++));
            }
            row--;
            column++;
        }
    }
  }
}

#Utilizar arranjos e matrizes como parâmetros de métodos

Arranjos = 
public class Main {   
   
public void ordint(int[]vetor) {   
    Arrays.sort(vetor);   
    int vtamanho = vetor.length;  
    for (int i = 0; i < vtamanho; i++) {    
        System.out.println(vetor[i]);   
        }
   }  
Matriz = 
   public void mostra(int matriz[][]){
    for(int i=0;i<lin;i++){
        System.out.println("");
    for(int j=0;j<col;j++){
        System.out.print(mat[i][j]+" ");
        }
       }
       
#Utilizar arranjos e matrizes como retorno de métodos

public class Main{
          public static void main(String[] args){
              int[] arr1 = {1, 2, 3, 4, 5};
              int[] arr2 = {2, 4, 6, 8, 10};
              addArrays(arr1, arr2);
          }
      }
 
 
 ---------------------------------------------------------------------------------------------------------------------
 
 ##Tratamento de exceções
 
 #Definição
 
 Criar tratamento para possíveis erros que podem vir da lógica do código ou ligados ao usuário:
 
 try
{
  //código que será realizado a exceção
}
catch(tipo_exceçao e)
{
  //ação
  
#Exceções comuns

#Divisão por 0

int a = 6;
int b = 0;
System.out.print(a / b);

catch (ArithmeticException e) {
System.out.println
("não é possível dividir por 0");

#Conversão de tipos de dados inválidos

public class Main {
     public static void main(String[] args) {
	try{
		Object o = new Object();
		String s = (String) o;
	} catch (Exception e) {
		System.out.println("Conversão Inválida"); 
	}
	}
  
#Acessar uma posição inválida em um arranjo

public static void main(String[] args) {
            try {
                ArrayList arl = new ArrayList<>();
                  lrl.get(99)
            } catch (IndexOutOfBoundsException  e) {
                System.out.print("Possição não encontrada");
            }
        }
 
#Acessar uma String nula

String s = null
		s.replace ("","")
		System.out.println("String substituida");
	}catch (NullPointerException e){
		System.out.println("String null");
	}catch (Exception e){
           e.printStackTrace();
        }
      }

  #Bloco para capturar uma exceção
  
  catch (NumberException i) { //exceção
  
  #Bloco para capturar diferentes exceções
  
 catch (NumberException i) { //várias exceções
 
 #Bloco finally
 
 finally { //comando para finalizar o bloco de exceção
 
 
#Lançar uma exceção

public class Main {
public static void main(String[] args)
 throws Exception{
  throw new Exception("Exceção");
  }
  
  
  ------------------------------------------------------------------------------------------------------------------------------
 
##Métodos estáticos

#Estrutura de declaração de um método estático

public static void  main (String [] args) {  
  mostrar();  
}  
static void ver() {  
  System.out.println ( "Hello World!" );  
}  

#Nomes válidos e boas práticas

-Padrões de camel case
-Classes gramaticais

#Parâmetros

public static void main(String[] args) {
Scanner leia = new Scanner(System.in);
System.out.println("Informe o número: ");
double n1 = leia.nextDouble(); 
//condições para receber os valores

#Retorno

Utilizado para retornar o valor

##Utilização de métodos estáticos

#Disponíveis na mesma classe

public static void  main (String [] args) {  
  System.out.println("Hello";  
}  

#Disponíveis em outra classe/arquivo

class Loja{
    static String number;

static String getNumber() {
	return number;
}

#Recursão

def carrossum(numCarros):
theSum = 0
for i in numCarros:
theSum = theSum + i
return theSum
print(carrossum([1,3])

----------------------------------------------------------------------------





  
  
 
 
 
 
 
 
 


